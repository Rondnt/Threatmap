const { Vulnerability, Threat, Asset } = require('../models');
const { successResponse, errorResponse } = require('../utils/responseFormatter');
const { Op } = require('sequelize');

exports.create = async (req, res) => {
  try {
    const { name, description, cvss_score, severity, affected_system, cve_id, discovery_date, status } = req.body;

    const vulnerability = await Vulnerability.create({
      name,
      description,
      cvss_score,
      severity,
      affected_systems: affected_system ? [affected_system] : [], // Map singular to array
      cve_id,
      discovered_at: discovery_date || new Date(), // Map discovery_date to discovered_at
      status: status || 'open',
      user_id: req.user.id
    });

    return successResponse(res, { vulnerability }, 'Vulnerabilidad creada exitosamente', 201);
  } catch (error) {
    console.error('Error creating vulnerability:', error);
    return errorResponse(res, 'Error al crear vulnerabilidad', 500);
  }
};

exports.getAll = async (req, res) => {
  try {
    const { page = 1, limit = 10, severity, status, search } = req.query;
    const offset = (page - 1) * limit;

    const where = { user_id: req.user.id };

    if (severity) {
      where.severity = severity;
    }

    if (status) {
      where.status = status;
    }

    if (search) {
      where[Op.or] = [
        { name: { [Op.like]: `%${search}%` } },
        { description: { [Op.like]: `%${search}%` } },
        { cve_id: { [Op.like]: `%${search}%` } }
      ];
    }

    const { count, rows: vulnerabilities } = await Vulnerability.findAndCountAll({
      where,
      limit: parseInt(limit),
      offset: parseInt(offset),
      order: [['createdAt', 'DESC']]
    });

    return successResponse(res, {
      vulnerabilities,
      pagination: {
        total: count,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(count / limit)
      }
    }, 'Vulnerabilidades obtenidas exitosamente', 200);
  } catch (error) {
    console.error('Error fetching vulnerabilities:', error);
    return errorResponse(res, 'Error al obtener vulnerabilidades', 500);
  }
};

exports.getById = async (req, res) => {
  try {
    const { id } = req.params;

    const vulnerability = await Vulnerability.findOne({
      where: { id, user_id: req.user.id }
    });

    if (!vulnerability) {
      return errorResponse(res, 'Vulnerabilidad no encontrada', 404);
    }

    return successResponse(res, { vulnerability }, 'Vulnerabilidad obtenida exitosamente', 200);
  } catch (error) {
    console.error('Error fetching vulnerability:', error);
    return errorResponse(res, 'Error al obtener vulnerabilidad', 500);
  }
};

exports.update = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, cvss_score, severity, affected_system, cve_id, discovery_date, status } = req.body;

    const vulnerability = await Vulnerability.findOne({
      where: { id, user_id: req.user.id }
    });

    if (!vulnerability) {
      return errorResponse(res, 'Vulnerabilidad no encontrada', 404);
    }

    await vulnerability.update({
      name,
      description,
      cvss_score,
      severity,
      affected_systems: affected_system ? [affected_system] : [], // Map singular to array
      cve_id,
      discovered_at: discovery_date || vulnerability.discovered_at, // Map discovery_date to discovered_at
      status
    });

    return successResponse(res, { vulnerability }, 'Vulnerabilidad actualizada exitosamente', 200);
  } catch (error) {
    console.error('Error updating vulnerability:', error);
    return errorResponse(res, 'Error al actualizar vulnerabilidad', 500);
  }
};

exports.deleteVulnerability = async (req, res) => {
  try {
    const { id } = req.params;

    const vulnerability = await Vulnerability.findOne({
      where: { id, user_id: req.user.id }
    });

    if (!vulnerability) {
      return errorResponse(res, 'Vulnerabilidad no encontrada', 404);
    }

    await vulnerability.destroy();

    return successResponse(res, null, 'Vulnerabilidad eliminada exitosamente', 200);
  } catch (error) {
    console.error('Error deleting vulnerability:', error);
    return errorResponse(res, 'Error al eliminar vulnerabilidad', 500);
  }
};

exports.getStatistics = async (req, res) => {
  try {
    const where = { user_id: req.user.id };

    const total = await Vulnerability.count({ where });

    const bySeverity = {
      critical: await Vulnerability.count({ where: { ...where, severity: 'critical' } }),
      high: await Vulnerability.count({ where: { ...where, severity: 'high' } }),
      medium: await Vulnerability.count({ where: { ...where, severity: 'medium' } }),
      low: await Vulnerability.count({ where: { ...where, severity: 'low' } })
    };

    const byStatus = {
      open: await Vulnerability.count({ where: { ...where, status: 'open' } }),
      in_progress: await Vulnerability.count({ where: { ...where, status: 'in_progress' } }),
      patched: await Vulnerability.count({ where: { ...where, status: 'patched' } }),
      accepted: await Vulnerability.count({ where: { ...where, status: 'accepted' } })
    };

    // Vulnerabilidades críticas y altas abiertas
    const criticalOpen = await Vulnerability.count({
      where: {
        ...where,
        severity: { [Op.in]: ['critical', 'high'] },
        status: 'open'
      }
    });

    return successResponse(res, {
      statistics: {
        total,
        by_severity: bySeverity,
        by_status: byStatus,
        critical_open: criticalOpen
      }
    }, 'Estadísticas obtenidas exitosamente', 200);
  } catch (error) {
    console.error('Error fetching statistics:', error);
    return errorResponse(res, 'Error al obtener estadísticas', 500);
  }
};

exports.associateThreat = async (req, res) => {
  try {
    // Esta funcionalidad requiere una tabla intermedia vulnerability_threats
    // Por ahora retornamos que no está implementada
    return errorResponse(res, 'Funcionalidad por implementar', 501);
  } catch (error) {
    console.error('Error associating threat:', error);
    return errorResponse(res, 'Error al asociar amenaza', 500);
  }
};
